第一章 面试题基础篇
1.1 Go
### 面试题：Go的协程是怎么实现的？
> 明确一点：Go的协程本质上是用户级的线程，在语言层面，使用起来和其他语言的线程没有太大的区别。本质上的能力是Go做的GMP调度。
> G：协程，用户通过go关键字创建的并发执行代码块。(用户级线程)
> M:  对应cpu的线程，是cpu真正执行的任务单元（内核级线程）
> P:  可以理解成Go对G和M的调度环境。（协程调度器），和M一一对应。
当用户手动开辟了一个G之后，会给这个G绑定一个P, 相当于加入到P的本地队列。由P去调度执行。当P的本地队列里面没有G, 或者G阻塞的时候，就会引起调度。从G的全局队列里面获取G并执行。
为什么会有P， 主要做的是一个调度作用。如果避免cpu核心线程出现空等。这里面的涉及的知识就比较多了，比如零拷贝、epoll等相关等知识。

### G都包含哪些信息？哪些是共用的？
包含当前的堆栈信息和维护当前状态所需的对象。

### Go Map的原理
一般通过：数组+链表+红黑树的方式实现。
发生冲突：链地址法/再Hash法(开放地址法)/建立公共溢出区域
Go使用数组+链表的方式进行处理。
底层使用数据结构是hmap，存在一个字段buckets，指向桶数组，每个桶数组的结构是bmap，一个桶只能存储8对数据，如果超过了，就会在overflow里面连接到下一个bmap。

查找数据：必然需要知道桶的长度，在bmap中存在一个b的结构，比如说b是4，就用hash结果的后四位来定位在那个桶，找到桶之后，根据高八位确定在桶的那个位置，通过overflow寻找。

扩容方式：等量扩容/2倍容量扩容
>  等量扩容：其实就是内存的一个整理，并不会增加新的容量
>  2倍容量扩容：扩容成原来的两倍，b会增加1，这时候桶的位置会发生一个调整。但是桶里面的链表是不会发生变化的。

何时进行扩容：
> 装载因子 > 6.5 (map中的数量/桶的数量)
> 链表过长，map不平衡。b < 15， bucket的数量超过一定数值。
> 扩容非一次完成，会有oldBucket保存原来的map，读的时候会遍历两个map，写的时候就直接在新的bucket里面写。

1.2 操作系统
### 什么是page cache？
因为cpu读取内存的速度和读取磁盘的速度之间存在差异，为了加速这个流程。就有了pagecache这个东西。当在代码里面读取 文件的时候，并不是直接读取的磁盘的文件，而是申请一个页缓存（page cache），pagecache按照一定大小一次性读取4k或者8k的数据到内存中，供cpu使用。一般cpu使用，都不会超过4k，避免了和磁盘多次交互的过程。一般和文件的操作，都会有这一层的操作，比如mysql按照页来读取数据库的数据。

### 操作系统进程的定义？一个进程有哪些东西。
以前比较老的计算机，都是单核单线程的，同一时间只能有一个程序运行。但是计算机是一个并行运行的机器，进程就是在cpu上面运行的基本单位。
1、进程是程序的一次执行过程。
2、进程是一个程序和其数据在处理机上顺序执行的活动。
3、进程是具有独立功能的程序在数据集上运行的过程。是系统进行资源分配和调度的独立单位。

进程的组成：
1、数据段：程序运行过程中需要的数据
2、程序段：程序代码
3、PCB：操作系统通过pcb来管理进程，pcb中包含操作系统对其管理的各种信息。（pid，分配的资源列表，各种cpu存储器的值）

### 进程之间通信的方式
> 管道：最常见的就是“｜”，是一个匿名管道。我们在使用的是否，可以使用mkfifo myPipe 创建一个管道，对其进行数据的读写。本质上，管道是内核的一段缓存，并不属于文件系统。在创建时需要两个参数，分别是接收端和发送端的pid，所以经常用在父子进程之间的通信。效率很低，不合适进程间频繁的交换数据。

> 消息队列：内核中的一段链表，发送端发送消息之后，不会阻塞。（管道方式存在阻塞），接收端处理可以异步的处理消息。但是也存在一些问题，比如在内核中，消息的长度是有限制的，不推荐发送大量的消息。同时因为是异步的，也会存在消息处理的时间问题。存在内核态和用户态的交互。

> 共享内存：不涉及内核态，单独的划分出一个空间，两个进程共享。其实实现也很简单，因为都是虚拟内存。只需要两个进程映射到同一个内存空间就好。

> 信号量：在共享内存的时候，可能出现两个进程同时操作一块内存空间的情况，导致内存空间出错。这时候就需要加锁。信号量就是加锁的方式，能够保证读写共享内存的正确性。

> 信号：经常在我们开发go的程序的时候，都会在程序运行之后，监听一些信号。比如：SIGINT，就是在监听到用户输入control + c的时候触发。保证代码的正常的运行。

> Socket: 接套字，基于网络。
