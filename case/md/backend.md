第一章 面试题基础篇
1.1 Go
### 面试题：Go的协程是怎么实现的？
> 明确一点：Go的协程本质上是用户级的线程，在语言层面，使用起来和其他语言的线程没有太大的区别。本质上的能力是Go做的GMP调度。
> G：协程，用户通过go关键字创建的并发执行代码块。(用户级线程)
> M:  对应cpu的线程，是cpu真正执行的任务单元（内核级线程）
> P:  可以理解成Go对G和M的调度环境。（协程调度器），和M一一对应。
当用户手动开辟了一个G之后，会给这个G绑定一个P, 相当于加入到P的本地队列。由P去调度执行。当P的本地队列里面没有G, 或者G阻塞的时候，就会引起调度。从G的全局队列里面获取G并执行。
为什么会有P， 主要做的是一个调度作用。如果避免cpu核心线程出现空等。这里面的涉及的知识就比较多了，比如零拷贝、epoll等相关等知识。

### G都包含哪些信息？哪些是共用的？
包含当前的堆栈信息和维护当前状态所需的对象。

### Go Map的原理
一般通过：数组+链表+红黑树的方式实现。
发生冲突：链地址法/再Hash法(开放地址法)/建立公共溢出区域
Go使用数组+链表的方式进行处理。
底层使用数据结构是hmap，存在一个字段buckets，指向桶数组，每个桶数组的结构是bmap，一个桶只能存储8对数据，如果操作了，就会在overflow里面连接到下一个bmap。

查找数据：必然需要知道桶的长度，在bmap中存在一个b的结构，比如说b是4，就用hash结果的后四位来定位在那个桶，找到桶之后，根据高八位确定在桶的那个位置，通过overflow一致寻找。

扩容方式：等量扩容/2倍容量扩容
>  等量扩容：其实就是内存的一个整理，并不会增加新的容量
>  2倍容量扩容：扩容成原来的两倍，b会增加1，这时候桶的位置会发生一个调整。但是桶里面的链表是不会发生变化的。

何时进行扩容：
> 装载因子 > 6.5 (map中的数量/桶的数量)
> 链表过长，map不平衡。b < 15， bucket的数量超过一定数值。
> 扩容非一次完成，会有oldBucket保存原来的map，读的时候会遍历两个map，写的时候就直接在新的bucket里面写。
